## 函数


### 字符串的链式操作
```go
package main

import (
	"fmt"
	"strings"
)

func StringProcess(list []string, chain []func(string) string) {
	// 遍历每个字符串
	for index, str := range list {
		// 需要处理的字符串
		result := str

		// 遍历处理链
		for _, proc := range chain {

			// 输入一个字符串进行处理， 返回数据作为下一个处理链的输入
			result = proc(result)
		}

		// 结果返回给切片
		list[index] = result
	}
}

// 移除前缀
func removePrefix(str string) string {
	return strings.TrimPrefix(str, "go")
}

func main() {
	// 待处理的字符串列表
	list := []string{
		"go scanner",
		"go parser",
		"go compiler",
		"go printer",
		"go formater",
	}

	// 处理函数作用连
	chain := []func(string) string{
		removePrefix,      // 移除前缀
		strings.TrimSpace, // 移除空格
		strings.ToUpper,   // 转大写
	}

	// 处理字符串
	StringProcess(list, chain)

	for _, str := range list {
		fmt.Println(str)
	}
}
```


### 把函数作为接口调用
```go
package main

import "fmt"

// 调用器接口
type Invoker interface {
	// 实现一个Call方法
	Call(interface{})
}

// 结构体类型
type Type struct {
}

// 实现 Invoker 的 Call 方法
func (s *Type) Call(p interface{}) {
	fmt.Println("form struct: ", p)
}

// 函数定义为类型
type FuncCaller func(interface{})

// 实现 Invoker 的 Call 方法
func (f FuncCaller) Call(p interface{}) {
	f(p)
}

func main() {
	// 申明接口变量
	var invoker Invoker

	// 实例化结构体
	s := new(Type)

	// 讲师李华的结构体赋值到接口
	invoker = s

	// 调用实例化结构体的方法 Type.Call
	invoker.Call("hello")

	// 匿名函数转为 FuncCaller 类型， 之后赋值给接口
	invoker = FuncCaller(func(value interface{}) {
		fmt.Println("form function: ", value)
	})

	// 使用接口调用 FuncCaller.call 内部会调用函数本体
	invoker.Call("hello")
}
```

### 闭包的两个场景
**记忆效应**                            
```go
package main

import "fmt"

func Accumulate(value int) func() int {
	return func() int {
		value++
		return value
	}
}

func main() {
	accumulator := Accumulate(1)

	// 累加1并且打印
	fmt.Println(accumulator())
	fmt.Println(accumulator())

	// 打印累加器的函数地址
	fmt.Printf("%p\n", &accumulator)

	// 新创建一个累加器
	accumulator2 := Accumulate(10)

	// 累加
	fmt.Println(accumulator2())

	// 打印累加器的函数地址
	fmt.Printf("%p\n", &accumulator2)
}
/*
结果：
2
3
0xc00000e028
11
0xc00000e038
*/
```

**实现生成器**                               
```go
package main

import "fmt"

func playerGen(name string) func() (string, int) {
	hp := 50
	return func() (string, int) {
		return name, hp
	}
}

func main() {
	generator := playerGen("yanle")

	name, ph := generator()

	fmt.Println(name, ph)
}
```


### 可变参数
```go
func myfunc(args ...int) {
    for _, arg := range args {
        fmt.Println(arg)
    }
}
```

#### 任意类型的可变参数
可以指定类型为 interface{}
```go
func Printf(format string, args ...interface{}) {
    // ...
}
```

用 interface{} 传递任意类型数据是Go语言的惯例用法
```go
package main

import "fmt"

func myPrint(args ...interface{}) {
	for _, arg := range args {
		switch arg.(type) {
		case int:
			fmt.Println(arg, " is an int value")
		case string:
			fmt.Println(arg, " is a string value")
		case int64:
			fmt.Println(arg, " is an int64 value")
		default:
			fmt.Println(arg, " is an unknown type")
		}
	}
}

func main() {
	var v1 = 1
	var v2 int64 = 234
	var v3 = "hello"
	var v4 = 1.2

	myPrint(v1, v2, v3, v4)
}
```

#### 遍历可变参数列表 
利用for range 遍历                      
```go
package main

import (
	"bytes"
	"fmt"
)

// 让参数链接为字符串
func joinStrings(slist ...string) string {
	// 定义一个字节缓冲， 用于快速的链接字符串
	var b bytes.Buffer

	for _, s := range slist {
		b.WriteString(s)
	}

	return b.String()
}

func main() {
	fmt.Println(joinStrings("yanle ", "le ", "is ", "coding"))
}
```

#### 获得可变参数类型
当可变参数为 interface{} 类型时，可以传入任何类型的值，此时，如果需要获得变量的类型，可以通过 switch 获得变量的类型
```go
package main

import (
	"bytes"
	"fmt"
)

func printTypeValue(slist ...interface{}) string {
	var b bytes.Buffer

	for _, s := range slist {
		// 将interface{}的参数转为字符串
		str := fmt.Sprintf("%v", s)

		var typeString string

		switch s.(type) {
		case bool:
			typeString = "bool"
		case string:
			typeString = "string"
		case int:
			typeString = "int"
		}

		b.WriteString("value: ")
		b.WriteString(str)
		b.WriteString(" type: ")
		b.WriteString(typeString)
		b.WriteString("\n")
	}
	return b.String()
}

func main() {
	fmt.Println(printTypeValue(100, "str", false))
}
```



