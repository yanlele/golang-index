## 语言结构容器


### 数组

**申明**                              
方式1： `var 数组变量名 [元素数量]Type`                                                 
方式2： `var q [3]int = [3]int{1, 2, 3}`                                   
方式3： `q := [...]int{1, 2, 3}`                           


**遍历数组**                                    
`for index, value := range arr {}`         


**举例子**                             
```go
package main

import "fmt"

func main() {
	a := [...]int{1, 2, 3}
	fmt.Println(a[0])
	fmt.Println(a[len(a)-1])

	for index, value := range a {
		fmt.Printf("index: %d, value: %d \n", index, value)
	}
}
```


### 多维数组
**申明**                              

方式1：                            
```go
// 声明一个二维整型数组，两个维度的长度分别是 4 和 2
var array [4][2]int
// 使用数组字面量来声明并初始化一个二维整型数组
array = [4][2]int{{10, 11}, {20, 21}, {30, 31}, {40, 41}}
// 声明并初始化数组中索引为 1 和 3 的元素
array = [4][2]int{1: {20, 21}, 3: {40, 41}}
// 声明并初始化数组中指定的元素
array = [4][2]int{1: {0: 20}, 3: {1: 41}}
```

方式2：                                    
````go
// 声明一个 2×2 的二维整型数组
var array [2][2]int
// 设置每个元素的整型值
array[0][0] = 10
array[0][1] = 20
array[1][0] = 30
array[1][1] = 40
````


方式3：                                
```go
// 声明两个二维整型数组
var array1 [2][2]int
var array2 [2][2]int
// 为array2的每个元素赋值
array2[0][0] = 10
array2[0][1] = 20
array2[1][0] = 30
array2[1][1] = 40
// 将 array2 的值复制给 array1
array1 = array2
```

### 数组切片
`slice [开始位置 : 结束位置]`                           

举例子：                        
```go
package main

import "fmt"

func main() {
	var arr [30]int
	for i := 0; i < 30; i++ {
		arr[i] = i + 1
	}

	fmt.Println(arr)

	fmt.Println(arr[:20])
	fmt.Println(arr[20:])

	fmt.Println(arr[:])
	fmt.Println(arr[0:0])
}

/* 结果一次如下
[1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30]
[1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20]
[21 22 23 24 25 26 27 28 29 30]
[1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30]
[]
*/
```

#### 切片的申明
申明方式1：                      
```go
// 声明字符串切片
var strList []string

// 声明整型切片
var numList []int

// 声明一个空切片
var numListEmpty = []int{}
```

申明方式2: `make( []Type, size, cap )`                         
```go
a := make([]int, 2)
b := make([]int, 2, 10)

fmt.Println(a, b)
fmt.Println(len(a), len(b))
```



### append
```go
package main

import "fmt"

func main() {
	var arr []int
	arr = append(arr, 1)
	fmt.Println(arr)

	arr = append(arr, 2, 3, 4, 5)
	fmt.Println(arr)

	arr = append(arr, []int{6, 7, 8}...)
	fmt.Println(arr)

	arr = append([]int{0}, arr...)
	fmt.Println(arr)

	arr = append([]int{-3, -2, -1}, arr...)
	fmt.Println(arr)
}

/*
结果：
[1]
[1 2 3 4 5]
[1 2 3 4 5 6 7 8]
[0 1 2 3 4 5 6 7 8]
[-3 -2 -1 0 1 2 3 4 5 6 7 8]
*/
```

### 复制切片
`copy( destSlice, srcSlice []T) int`                        
如果加入的两个数组切片不一样大，就会按照其中较小的那个数组切片的元素个数进行复制。                           

demo1:                      
```go
package main

import "fmt"

func main() {
	slice1 := []int{1, 2, 3, 4, 5}
	slice2 := []int{6, 7, 8}

	copy(slice1, slice2)
	fmt.Println(slice1)
	// 结果：[6 7 8 4 5]

	//copy(slice2, slice1)
	//fmt.Println(slice2)
	// 结果：[1 2 3]
}
```


demo2:                                  
```go
package main

import "fmt"

func main() {

	// 设置元素数量为1000
	const elementCount = 1000

	// 预分配足够多的元素切片
	srcData := make([]int, elementCount)

	// 将切片赋值
	for i := 0; i < elementCount; i++ {
		srcData[i] = i
	}

	// 引用切片数据
	refData := srcData

	// 预分配足够多的元素切片
	copyData := make([]int, elementCount)
	// 将数据复制到新的切片空间中
	copy(copyData, srcData)

	// 修改原始数据的第一个元素
	srcData[0] = 999

	// 打印引用切片的第一个元素
	fmt.Println(refData[0])

	// 打印复制切片的第一个和最后一个元素
	fmt.Println(copyData[0], copyData[elementCount-1])

	// 复制原始数据从4到6(不包含)
	copy(copyData, srcData[4:6])

	for i := 0; i < 5; i++ {
		fmt.Printf("%d ", copyData[i])
	}
}

/*
结果：
999
0 999
4 5 2 3 4
*/
```

### 删除指定元素
```go
package main

import "fmt"

func main() {
	var arr = []int{1, 2, 3, 4, 5}

	// 删除第一个元素
	fmt.Println(arr[1:])
	// 删除前三个元素
	fmt.Println(arr[3:])

	// 删除第三个元素
	fmt.Println(append(arr[:2], arr[3:]...))
	// 删除第三和第四个元素
	fmt.Println(append(arr[:2], arr[4:]...))

	// 删除最后一个元素
	fmt.Println(arr[:len(arr)-1])
	// 删除最后两个元素
	fmt.Println(arr[:len(arr)-2])
}
```


